```
함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 둘을 구분할 거의 유일한 기능
상황별로 this가 어떻게 달라지는지, 왜 그렇게 되는지, 예상과 다른 대상을 바라볼 때 그 원인을 효과적으로 추적하는 방법 이해
```

## 3-1. 상황에 따라 달라지는 this

- 실행 컨텍스트 생성될 때 this가 결정됨 = 함수를 호출할 때 결졍됨

### 3-1-1. 전역 공간에서의 this

- 전역공간에서 this는 전역객체를 가리킴 (전역 컨텍스트를 생성하는 주체가 전역 객체)

- 전역객체는 런타임 환경에 따라 다른 이름과 정보를 가짐

  -> 브라우저 환경 전역객체는 window, Node.js 환경에서는 global

- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할당 (변수이자 전역객체의 프로퍼티)

- 자바스크립트의 모든 변수는 특정 객체의 프로퍼티로서 동작

  -> 특정 객체 실행컨텍스트의 LexicalEnvironment (L.E)

  -> 전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조 (globalEnv가 전역객체를 참조 -> 전역컨텍스트의 L.E가 globalEnv를 참조)

- '전역변수를 선언하면 자동으로 전역객체의 프로퍼티로도 할당된다' (X)

  '전역변수를 선언하면 전역객체의 프로퍼티로 할당된다' (O)

```
window.a = 1
this.a = 1
a = 1

동일하게 1이 나오는 이유
변수 a에 접근하고자 스코프 체인에서 a를 탐색하면
가장 마지막에 전역 스코프의 Lexcial.에서 a를 발견해서 반환
(window.)a 생략된것이라 여겨도 무방

window. 에 할당된 변수는
(window.) 생략된 채도 똑같이 동작함
그러나 delete의 경우 그렇게 안됨
```

```
var a = 1;
delete window.a;

var a = 1;
delete a;
// false
(할당이 바로 전역변수로 할당된 경우)

window.b = 1;
delete window.b;

window.b
delete b;
// true
(할당이 바로 전역객체에 할당된 경우)
```

- 자바스크립트 엔진에서

  전역변수로 할당하고 전역객체에 등록될 경우에는 configurable 속성 (변경 및 삭제 가능성)을 false로 정의함

  -> 이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이 보임

### 3-1-2. 메서드로서 호출할 때 그 메서드 내부에서의 this

**함수 vs 메서드**

- 어떤 함수를 실행하는 방법 여러가지 그 중 2가지 = 함수로서 실행, 메서드로서 실행

- 함수와 메서드는 정의된 동작을 수행하는 코드 뭉치

- 함수와 메서드의 차이는 '독립성'

- 함수는 그 자체로 독립적인 기능, 메서드는 자신을 호출한 대상 객체에 관한 동작 수행

(같은 함수라도 독립적으로 실행하는지, 객체내의 프로퍼티에 할당하고 실행하는지 차이 존재)

**메서드 내부에서의 this**

- 객체.method() = 객체 this

### 3-1-3. 함수로서 호출할 때 그 함수 내부에서의 this

**함수 내부에서의 this**

- 실행컨텍스트 생성 시 this 지정되지 않은 경우 전역객체를 바라본다고 함

  더글라스 크락포드는 '설계상의 오류'라함

**메서드의 내부함수에서의 this**

- 예측가능함, 호출한 객체가 this

**메서드의 내부 함수에서의 this를 우회하는 방법**

- 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 당시 주변 환경의 this를 그대로 상속받아 사용가능하면 좋겠다

  변수를 검색하면 우선 가장 가까운 스코프의 L.E를 찾고 없으면 상위 스코프를 검색하듯이... this 역시

  현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 ...

- 상위 컨텍스트에서 변수 self에 this (호출 객체)를 할당시켜 함수 내부에서 사용

**this를 바인딩하지 않는 함수**

- ES6에서는 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정자체가 빠짐

  -> 상위 스코프의 this를 그대로 활용

### 3-1-4. 콜백 함수 호출 시 그 함수 내부에서의 this

- 함수 A(또는 메서드)의 제어권을 B에게 넘겨주는 경우 함수 A를 '콜백 함수'라 함

- 함수 A는 this가 지정되지 않은 경우 전역객체, 아닌경우 B 내부로직에서 정한 규칙에 따라 바인딩됨

### 3-1-5. 생성자 함수 내부에서의 this

- 생성자 함수는 공통된 성질을 지닌 객체를 생성하는데 사용하는 함수

- 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라 칭함

- 생성자는 인스턴스를 만들기 위한 틀

- 클래스에는 공통 속성들이 준비되어있고, 개성들 덧붙여 인스턴스를 생성

- 자바스크립트는 함수에 생성자 역할을 부여, new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작

  -> this는 곧 새로 만들 구체적인 인스턴스 자신이 됨

## 3-2. 명시적으로 this를 바인딩하는 방법

```
자동으로 this바인딩 되는 경우말고 별도의 대상으로 바인딩하는 방법 이해
```

### 3-2-1. call 메서드

```
call 메서드는 첫번째 인자로 this 바인딩할 것을 넣음
나머지 인자들은 순서대로 매개변수
```

### 3-2-2. apply 메서드

```
call 메서드와 기능적으로 동일하나
두번째 인자로 매개변수를 받는데 이를 배열 형태로 받음
```

### 3-2-3. call/apply 메서드의 활용

**유사배열객체(array-like object)에 배열 메서드를 적용**

```
객체에는 배열 메서드를 직접 적용 불가
그러나 index와 length가 0 또는 양의 정수 (0 =< index, length)
즉, 배열구조와 유사한 경우 call,apply 메서드로 배열 메서드 차용가능
(index와 length 를 가진 문자열도 가능하지만 변경을 가하는 배열 메서드는 에러를 던짐 (문자열의 length는 읽기전용이라!!!),
concat의 경우 반드시 배열이 대상이어야하고 에러는 안나지만 결과가 제대로 나지않음)

var obj = {
  0: 'a',
  1: 'b',
  length: 2
}

Array.prototype.push.call(obj, 'c')
console.log('obj', obj)
// { 0: 'a', 1: 'b', 2: 'c', length: 3 }

var arr = Array.prototype.slice.call(obj)
console.log('arr', arr)
// ['a', 'b', 'c', 'd']
// slice 매개변수 없는 경우 원래 얕은 복사본 배열 반환
```

- 위와 같은 방식은 코드의 숨은 의도를 알지못하면 이해하기 어려워 ES6에서는

  유사배열객체 또는 순회 가능한 데이터 타입을 배열로 반환하는 Array.from 메서드가 생김

**생성자 내부에서 다른 생성자를 호출**

- 생성자 함수내에서 call/apply를 이용해 다른 생성자 함수를 호출 시 중복코드 줄이기 가능

**여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용**

```
var numbers = [1,2,3,4,5]
var max = Math.max.apply(null, numbers)
var min = Math.min.apply(null, numbers)
console.log(max, min)
// 5, 1

ES6에서는

console.log(Math.max(...numbers))
console.log(Math.min(...numbers))
```

### 3-2-4. bind 메서드

- ES5에서 추가된 메서드, call과 비슷하지만 즉시 실행하지 않고 넘겨받은 this와 인자를 바탕으로 새로운 함수 반환

  -> 인자들은 반환된 함수를 호출 시 추가적으로 등록해서 실행도 가능 (부분 적용 함수)

**name 프로퍼티**

- bind 메서드를 적용해서 만든 함수는 name 프로퍼티에 'bound'가 접두어로 붙음, 추적이 타 메서드에 비해 수월

**상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기**

- this 우회법으로 self 등을 소개했는데, call, apply, bind 메서드 활용 가능

### 3-2-5. 화살표 함수의 예외사항

- 위의 경우 화살표 함수로 변경해도 됨

### 3-2-6. 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)

- 콜백함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체를(thisArg)를 인자로 지정 가능

- 이런 형태는 여러 내부요소에 대해 같은 동작을 반복 수행하는 '배열 메서드'에 많이 포진됨

  같은 이유로 ES6에 새로 등장한 Set, Map등의 메서드에도 일부 존재

```
Array.prototype.forEach(callback[, thisArg])
Array.prototype.map(callback[, thisArg])
Array.prototype.filter(callback[, thisArg])
Array.prototype.some(callback[, thisArg])
Array.prototype.every(callback[, thisArg])
Array.prototype.find(callback[, thisArg])
Array.prototype.findIndex(callback[, thisArg])
Array.prototype.flatMap(callback[, thisArg])
Array.prototype.from(callback[, thisArg])

Set.prototype.forEach(callback[, thisArg])
Map.prototype.forEach(callback[, thisArg])
```

## 3-3. 정리

1. 다음 규칙은 명시적 this 바인딩이 없는 한 늘 성립

- 전역공간에서 this는 전역객체 (브라우저는 window, Node.js는 global)참조

- 어떤 함수를 메서드로 호출한 경우 this는 메서드 호출 주체를 참조

- 함수로서 호출한 경우 전역객체 참조, 메서드의 내부함수도 동일(객체.메서드 가 아닌경우)

- 콜백 함수 내부에서의 this는 해당 콜백함수의 제어권을 넘겨받은 함수가 정의함, 정의하지않은 경우 전역객체

- 생성자 함수는 this는 생성할 인스턴스 참조

2. 명시적 바인딩 인경우

- call,apply 메서드는 this 명시적 지정하면서 함수 또는 메서드 호출

- bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로 함수 반환 (위와 같이 즉시 실행하지 않고 반환만 함)

- 요소를 순회해 콜백 함수를 호출하는 내용의 일부 메서드는 별도의 인자로 this 받기도 함
