## 1-1. 데이터 타입의 종류

```
데이터를 처리하는 과정 -> 기본형 타입과 참조형 타입의 동작차이 이해 -> 활용
데이터 타입과 관련된 개념 추가 이해
```

데이터 타입의 종류는

- 기본형 = primitive type , 원시형

- 참조형 = reference type

- 기본형에는 숫자(number), 문자열(string), 불리언(boolean), null, undefined, ES6에서 추가된 심볼(symbol)

- 참조형에는 객체(object), 배열(Array), 함수(Function), 날짜 (Date), 정규표현식(RegExp), ES6에 추가된 Map, WeakMap, Set, WeakSet (객체의 하위분류)

[Object와 Map 비교](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections#object%EC%99%80_map_%EB%B9%84%EA%B5%90)

- 기본형은 데이터가 담긴 주소값을 복제, 참조형은 데이터의 주솟값들을 담은 묶음의 주소값을 복제

- 기본형은 불변성, 참조형은 가변성

## 1-2. 데이터 타입에 관한 배경지식

### 1-2-1. 메모리와 데이터

- 컴퓨터는 모든 데이터를 0 또는 1로 바꿔 기억한다, 0 또는 1로 표현하는 하나의 메모리 조각을 비트(bit)라 함

- 메모리는 매우 많은 비트들로 구성, 비트는 고유한 `식별자`를 가져 위치 확인

- 비트를 하나의 단위로 묶어 표현할 수 있는 데이터의 개수 늘림, 검색 시간 줄임 = 비트를 적정한 개수로 묶은 단위 바이트 (1바이트 = 8비트, 256개의 값 표현)

- 정적 타입 언어는 메모리 낭비 최소화 위해 데이터 타입별로 할당할 메모리 영역 나누어 정해놓음, 그 이상의 값을 입력하면 오류가 나거나 잘못된 값이 저장됨

- 메모리 용량이 부족했던 시절과 달리 월등히 나아진 상황에 등장한 자바스크립트는 숫자의 경우 구분하지 않고 64비트 = 8바이트를 확보, 형변환 걱정이 훨씬 덜함

- 모든 데이터는 바이트 단위의 식별자 = 메모리 주소값을 통해서 서로 구분하고 연결됨

### 1-2-2. 식별자와 변수

- 변수와 식별자가 혼동되는 경우가 많음

- 변수는 변할 수 있는 무언가, 수학에서 차용된 용어라 변'수'이지만 컴퓨터 용어로 사용할 때는 다름

- 식별자는 데이터를 식별하는데 사용하는 이름, 즉 변수명

## 1-3. 변수 선언과 데이터 할당

### 1-3-1. 변수 선언

```
변수 선언하는 방법은 이미 알고있을테니, 동작 원리를 이해
```

예제 1-1. 변수 선언

```
var a;
```

- 변할 수 있는 데이터를 만든다.
  이 데이터의 식별자는 a로 한다.
  변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

- 변수와 데이터의 메모리 영역이 분리되어있음
  = 데이터 변경은 새로 데이터를 만드는 동작을 통해서만 이뤄짐
  = 필요한 데이터가 있으면 재활용, 없으면 새로 데이터 영역 생성해서 변수 영역에 할당 (저장)
  = 중복된 데이터 처리 효율이 높음
  데이터가 변경될 때마다 기존꺼를 수정하는게 아니라
  새로 데이터 영역을 만들어 저장하고 해당 데이터 영역의 주소값을
  변수 영역에 연결한다
  = 불변형

## 1-4. 기본형 데이터와 참조형 데이터

### 1-4-1. 불변값

- 변수(variable)와 상수(constant)를 구분하는 성질은 '변경 가능성'

- '변경 가능성'의 대상은 변수 영역, '불변성'의 대상은 데이터 영역

- '변경 가능성'은 변수 영역에 값을 재할당 할수 있느냐의 차이

### 1-4-2. 가변값

- '불변성'은 데이터 영역에 저장되는 값이 데이터냐 (데이터는 변경 시 새로운 데이터를 만들고 데이터 영역에 저장, 기존 데이터는 불변), 주소값이냐의 차이

- 그러나 참조형 데이터도 '불변값'을 활용한다

- 참조 카운트 : 데이터에 본인의 주소를 저장해 참조하는 변수의 개수, 참조 카운트가 0인 경우 메모리 주소는 가비지 컬렉터의 수거 대상이 됨

- 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때 자동으로 수거 대상을 수거함, 수거된 메모리는 할당 가능한 빈 공간이 됨

### 1-4-3. 변수 복사 비교

```
변수 복사할 때의 변화를 이해
```

- 복사 과정은 변수 영역과 데이터 영역이 분리되어 다른 변수에 동일한 데이터를 할당 시 동일한 주소값을 바라보게 됨, 여기서는 기본형과 참조형의 복사 과정은 동일

- 기본형과 참조형의 값을 변경 시 기본형은 데이터의 주소값이 변경되고, 참조형은 데이터 묶음의 주소값 안에 있는 주소값이 가리키는 데이터가 변경됨 (객체의 프로퍼티 변경)

- 만약에 기본형과 참조형 둘다 변수에 새로운 데이터를 할당하고자 하면 둘다 값(주소값)이 달라짐

## 1-5. 불변 객체

### 1-5-1. 불변 객체를 만드는 간단한 방법

- 참조형 데이터의 '가변성'은 데이터 자체가 아니라 내부 프로퍼티를 변경 시 성립, 기본형이든지 참조형이든지 데이터 자체를 (새 데이터 재할당) 변경하고자 하면 '불변성'이 됨

- 필요에 따라 객체의 프로퍼티를 변경할 때도 새로운 객체를 만들기 위해서 도구를 활용하면 객체 역시 '불변성' 확보 가능 (immutable.js, ES6의 spread operator, Object.assign 메서드...)

- 객체의 프로퍼티 변경 시 `가변성`으로 인해 객체 비교 시 동일한 값으로 보여진다.

### 1-5-2. 얕은 복사와 깊은 복사

- 얕은 복사 : 바래 아래 단계의 값만 복사 (중첩된 객체에서 참조형 데이터가 복사되면 주소값 그대로 복사됨, 원본(사본) 변경 시 원본과 사본이 동시 변경됨)

- 깊은 복사 : 내부의 모든 값 들을 하나하나 찾아서 전부 복사

## 1-6. undefined와 null

- undefined, null = 자바스크립트에서 '없음'을 나타내는 값 두 가지, 의미가 미세하게 다르고, 사용하는 목적이 다름
- undefined는 명시적으로 지정할 수도 있지만, 값이 없는 경우 자바스크립트 엔진이 자동으로 부여하는 경우도 존재

```
[1] 변수영역에 데이터영역이 연결되지 않은 식별자에 접근 (변수만 만들고 값 할당하지 않음)
[2] 객체 내부의 존재하지 않는 프로퍼티에 접근 (위와 동일)
[3] return 문이 없거나 호출되지 않는 함수의 실행 결과
```

- 배열 메서드 사용 시 비어있는 요소에 대해서 처리하지 않고 건너뜀
- '배열도 객체'임을 암시, 존재하지 않는 프로퍼티에 대해서는 순회할 수 없음
- 값이 지정되지 않은 인덱스는 '존재하지 않는 프로퍼티' 지나지 않음

- undefined를 직접 지정해준 경우는 하나의 값으로 동작, 값이 존재해 인덱스가 지정됨, 배열 순회의 대상이 될수있음
- 자바스크립트 엔진이 부여한 undefined는 인덱스와 값이 존재하지 않음

- '값이 없음'을 명시하기 위해서는 null 사용 권장
  null 사용 시 주의할 점 type of null은 'object'
  자바스크립트 자체 버그로 인해 비교 시 아래와 같이 비교

```
const n = null;
console.log(type of null) object

==> 위험
console.log(n == undefined) true
console.log(n == null) true

==> 비교
console.log(n === undefined) false
console.log(n === null) true
```
