```
실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체
자바스크립트의 동적 언어로서의 성격을 잘 파악할 수 있는 개념

실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(호이스팅,hoisting),
외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행
```

## 2-1. 실행 컨텍스트란?

```
스택과 큐의 개념에 대해 먼저 이해
스택은 출입구가 하나뿐인 깊은 우물갚은 데이터 구조
후입선출 (a,b,c,d 입력 -> d,c,b,a 출력)
데이터를 100개만 저장할 수 있는 우물에 100개 이상의 데이터를 넣으면
많은 프로그래밍 언어들이 이처럼 스택이 넘칠 때 에러를 던짐
= 스택오버플로우

큐는 양쪽이 열려있는 파이프
종류에 따라 양쪽 모두 입력,출력이 가능한 큐도 있으나
보통은 한쪽은 입력만, 다른 한쪽은 출력만 담당하는 구조
선입선출 (a,b,c,d 입력 -> a,b,c,d 출력)
```

참고) [자료구조-스택Stack과-큐Queue에-대해서-알아보자](https://jud00.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9DStack%EA%B3%BC-%ED%81%90Queue%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

- '동일한 환경'에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성

- 컨텍스트들을 콜스택에 담아뒀다가 가장 마지막에 쌓인 컨텍스트와 관련있는
  코드들을 실행하는 식으로 코드의 환경과 순서가 보장함

- '동일한 환경' = 하나의 실행 컨텍스트를 구성할 수 있는 방법 = 전역공간, eval() 함수, 함수 등..

- 자동으로 생성되는 전역공간과 eval() 함수 제외하면 흔히 실행 컨텍스트를 구성하는 방법은 '함수' 실행하는 것

- js 파일 실행하는 순간 자동으로 전역 컨텍스트 활성화됨, 그 다음 차례대로 코드 실행되던 중 함수만나 함수가 실행되면

  전역 컨텍스트 실행은 일시 중단되고, 함수의 컨텍스트를 생성한 후 콜 스택에 담김

- 함수의 컨텍스트 실행이 종료되면 해당 실행 컨텍스트는 콜 스택에서 제거됨,

  그럼 그 아래 콜스택에 존재한 컨텍스트가 다시 실행되고 종료되면 제거

- 실행 컨텍스트는 자바스크립트 엔진이 활용할 목적으로 생성함, 개발자가 코드를 통해서 확인 불가

```
VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보,
선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.
LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨
ThisBinding: this 식별자가 바라봐야 할 대상 객체
```

## 2-2. VariableEnvironment

- 초기에 스냅샷 Variable. 을 사용하고 그 뒤로 복사한 Lexical. 을 사용함, Variable. 과 Lexical. 의 내부는

  environmentRecord와 outer-EnvironmentReference로 구성되어있음

## 2-3. LexicalEnvironment

- '사전적인 환경', 컨텍스트를 구성하는 환경 정보들을 사전에 접하는 느낌으로 모아놓은 것

### 2-3-1. environmentRecord와 호이스팅

- 'environment'에는 현재 컨텍스트와 관련된 '식별자'들이 저장됨 (함수에 지정된 매개변수 식별자, 함수 선언, 선언된 변수(명) 등이 식별자에 해당)

```
전역 실행 컨텍스트는 변수 객체를 생성하는 대신, 자바스크립트 구동 환경이 제공하는
'전역 객체'를 활용함, '전역 객체'는 브라우저의 window, Node.js의 global 객체 등
자바스크립트 내장 객체(native object)가 아닌 호스트 객체(host object)로 분류
```

- 변수 정보 수집 완료했더라도, 실행 컨텍스트가 관여할 코드들은 실행되기 전 상태 (실행되기 전인데 환경 코드들의 변수명을 알고있음)

  -> '자바스크립트 엔진은 식별자들을 최상단에 끌어올려놓고 코드를 실행한다 (= 호이스팅)' 라고 해석에도 무방

**호이스팅 규칙** :

```
function a (x) {
  console.log(x);
  var x;
  console.log(x);
  var x = 2;
  console.log(x);
}
```

- 함수 인자로 넘겨진 매개변수는 코드 내부에서 변수를 선언한 것과 다른 점이 없다

  특히 Lexical. 입장에서는 완전히 동일, 그래서 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이뤄진 것으로 간주할 수 있음

- 호이스팅은 변수 정보를 수집하는 과정, environmentRecord는 실행될 컨텍스트 내의 어떤 식별자들이 있는지만 관심 있음

  식별자에 어떤 값이 할당될 것인지는 관심 없음, 호이스팅해서 변수명만 끌어올리고 할당 과정은 그 자리에 둡니다. (매개변수도 마찬가지)

**함수 선언문과 함수 표현식**

- 함수 선언문은 호이스팅 시 선언과 동시에 할당됨

- 함수 표현식은 호이스팅 시 선언만 되고, 할당은 그 자리에서 유지됨 (이로 인해 중첩되는 선언과 할당으로 인한 이슈를 방지할 수 있음)

- 함수 표현식은 '기명 함수 표현식'과 '익명 함수 표현식'이 존재, 일반적으로 익명 함수 표현식을 말함

```
var b = function () {}
console.log('b', b()) // OK
var c = function b () {}
console.log('c', c()) // OK = 익명 함수 표현식
console.log('b', b()) // 에러! = 기명 함수 표현식
```

- '기명 함수 표현식'의 함수명은 외부에서 접근 불가, 내부에서만 함수명으로 호출 가능 (재귀함수 용도로 사용가능, 그러나 내부에서도 c() 로 호출하면 되는데 .. 의문이라는 저자님)

### 2-3-2. 스코프, 스코프 체인, outerEnvironmentReference

- '스코프'란 식별자에 대한 유효범위

- 어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근가능, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다.

- ES5까지의 자바스크립트는 전역 공간 제외하고 오직 함수에서만 스코프가 생성됨 (ES6에서는 블록에 의해서 스코프 경계가 발생)

- '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것을 '스코프 체인'

  이를 가능케 하는 것이 LexicalEnvironment의 두번째 수집 자료인 outerEnvironmentReference

**스코프 체인**

- outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 Lexical.를 참조

- 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능

- 현재 실행 컨텍스트에서 변수가 발견되면 상위 스코프에 있는 변수에 접근할 수 없음 => '변수 은닉화'에 해당됨

**전역변수와 지역변수**

- 전역공간에서 선언한 변수는 전역변수, 함수내부에서 선언한 변수는 지역변수

- 함수 선언문과 함수 표현식에서 파트에서 나왔던 함수 선언문 관련한 이슈는 함수 내부에 선언했으면 해소되었을 이슈

-> 코드의 안정성을 위해 가급적 전역변수 최소화 필요

## 2-4. this

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장

- 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역객체가 저장

## 2-5. 정리

- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

- 실행 컨텍스트는 전역 공간에서 자동으로 생성되는 전역 컨텍스트와 eval 및 함수 실행에 의한 컨텍스트 등이 존재

- 실행 컨텍스트 객체는 활성화되는 시점에 variableEnvironment, LexicalEnvironment, ThisBinding 의 세가지 정보 수집

- 실행 컨텍스트를 생성할 때는 Variable.와 Lexical.가 동일한 내용으로 구성

- Lexical.는 함수 실행 도중에 변경되는 사항이 즉시 반영, 반면 Variable.는 초기 상태 유지

- Lexical.은 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집하는 environmentRecord와

  바로 직전의 컨텍스트의 LexicalEnvironment 정보를 참조하는 outerEnvironmentReference로 구성

- 호이스팅은 코드 해석을 수월하게 하기 위해 environmentRecord의 수집 과정을 추상화한 개념

  (선언문과 호이스팅되고, 할당과정은 그 자리에 남게됨)

- 스코프는 변수의 유효범위, outerEnvironmentReference는 해당 함수가 선언된 위치의 Lexical. 를 참조

- 코드 상에서 어떤 변수를 접근하려고 하면 현재 컨텍스트의 Lexical.에서 탐색하고 발견하면 그값을 반환,

  미발견시 outerEnvironmentReference에 담긴 Lexical. 에서 탐색함

  전역 컨텍스트까지 가서 미발견 시 undefined

- 전역 컨텍스트의 Lexcial.에 담긴 변수를 '전역변수'라고 함,

  그 외에 함수에 의해 생성된 실행 컨텍스트의 변수들을 '지역변수'

- this에는 실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장, 지정되지 않은 경우 전역객체가 저장됨
